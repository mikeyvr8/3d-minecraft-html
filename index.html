<!--
Mini-Minecraft 3D — single-file HTML/JS game (advanced)
Drop this file as `index.html` in a GitHub repo and enable GitHub Pages (or serve from any static host).

Notes:
- Uses modern ES modules and Three.js from a CDN. Works in Chrome (including Chromebooks) and other modern browsers that support ES modules.
- Controls: Click to lock pointer then WASD to move, mouse to look, Space to jump, E to place block, Q to remove block.
- Features: 3D voxel world with chunks, efficient instanced rendering, simple lighting, block palette, texture-like colors, save/load to localStorage, export/import world as JSON, adjustable render distance.
- Single-file but depends on remote Three.js modules (recommended for compatibility and smaller file size). If you need a fully offline single file, I can inline a build of Three.js but it will be very large.

Compatibility tips for Chromebooks / school environments:
- If external CDN modules are blocked, upload this file to GitHub Pages (public) or host on a network that allows access to unpkg/jsdelivr.
- The game is optimized to run on low-power devices (instanced meshes, small default world/chunk size). You can reduce renderDistance in the UI.

Controls (brief):
- Click the canvas to enter pointer lock.
- Move: W/A/S/D, look with mouse.
- Jump: Space
- Place block: E (places currently selected block at crosshair)
- Remove block: Q (removes block at crosshair)
- Change block: 1-6 keys
- Save: S, Load: L, Export: Export JSON, Import: Import JSON

-->

<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mini Minecraft 3D — Advanced</title>
<style>
  :root{--bg:#071021;--panel:#0f1724;--muted:#9fb6c9}
  html,body{height:100%;margin:0;font-family:system-ui,Segoe UI,Roboto,Arial;background:linear-gradient(180deg,#071021,#0a1220);color:#e6eef6}
  #app{display:flex;height:100vh}
  canvas{flex:1;display:block}
  #ui{width:340px;padding:12px;background:var(--panel);box-shadow:0 6px 24px rgba(0,0,0,.6)}
  h1{margin:0;font-size:18px}
  .muted{color:var(--muted);font-size:13px}
  .palette{display:flex;flex-wrap:wrap;gap:8px;margin:8px 0}
  .blockBtn{width:48px;height:36px;border-radius:6px;display:flex;align-items:center;justify-content:center;cursor:pointer;border:2px solid transparent}
  .blockBtn.sel{outline:3px solid rgba(125,211,252,.18);border-color:rgba(255,255,255,.06)}
  .row{display:flex;gap:8px;margin:8px 0}
  button,input,select{background:#08121b;color:#dff;border:1px solid rgba(255,255,255,.04);padding:8px;border-radius:8px}
  textarea{width:100%;height:80px;background:#07121b;color:#dff;border-radius:8px;padding:8px}
  label{font-size:13px;color:var(--muted)}
  .small{font-size:13px;color:var(--muted)}
</style>
</head>
<body>
<div id="app">
  <canvas id="c"></canvas>
  <div id="ui">
    <h1>Mini Minecraft 3D</h1>
    <div class="muted">3D voxel sandbox — click canvas to play. Save/load & export/import world.</div>

    <div style="margin-top:10px">
      <div class="small">Block palette (1-6)</div>
      <div class="palette" id="palette"></div>
    </div>

    <div class="row">
      <button id="saveBtn">Save (S)</button>
      <button id="loadBtn">Load (L)</button>
      <button id="exportBtn">Export JSON</button>
      <button id="importBtn">Import JSON</button>
    </div>
    <div class="row"><label>Render distance: <select id="renderDist"><option>2</option><option selected>3</option><option>4</option><option>5</option></select></label></div>
    <div style="margin-top:8px"><label class="small">Tips: Use Q/E to remove/place at center crosshair. Press Esc to release pointer lock.</label></div>
    <div style="margin-top:10px"><textarea id="importExport" placeholder='Paste exported JSON here to import'></textarea></div>
    <div style="margin-top:8px" class="small">Performance: Instanced rendering, adjustable chunk distance for Chromebooks/low-end devices.</div>
  </div>
</div>

<script type="module">
// Uses Three.js modules from CDN — modern browsers (Chrome/Chromebooks) support this.
import * as THREE from 'https://unpkg.com/three@0.153.0/build/three.module.js';
import { PointerLockControls } from 'https://unpkg.com/three@0.153.0/examples/jsm/controls/PointerLockControls.js';

// --- Config ---
const CHUNK_SIZE = 16; // blocks per axis in chunk
const WORLD_CHUNKS = {x:4,z:4}; // number of chunks in X and Z (small default for performance)
const BLOCK_TYPES = [
  {id:0,name:'Air',color:null},
  {id:1,name:'Grass',color:0x74b35c},
  {id:2,name:'Dirt',color:0x8a5a3b},
  {id:3,name:'Stone',color:0x8f918f},
  {id:4,name:'Wood',color:0xa46f32},
  {id:5,name:'Water',color:0x3aa0e3},
  {id:6,name:'Sand',color:0xe2d59f},
];

// --- State ---
const canvas = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.shadowMap.enabled = true;
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);

const camera = new THREE.PerspectiveCamera(75, 2, 0.1, 1000);
camera.position.set(8, 12, 8);

const controls = new PointerLockControls(camera, canvas);
canvas.addEventListener('click', ()=>{ controls.lock(); });

// Lighting
const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8); scene.add(hemi);
const dir = new THREE.DirectionalLight(0xffffff, 0.8); dir.position.set(50,100,50); dir.castShadow=true; scene.add(dir);

// Simple ground / skybox feel
scene.fog = new THREE.FogExp2(0x87ceeb, 0.002);

// World representation: map chunkKey -> Uint8Array(CHUNK_SIZE^3)
const chunks = new Map();
function chunkKey(cx,cz){return `${cx},${cz}`} 

// Create a small procedural world
function makeChunk(cx,cz){
  const arr = new Uint8Array(CHUNK_SIZE*CHUNK_SIZE*CHUNK_SIZE);
  for(let x=0;x<CHUNK_SIZE;x++){
    for(let z=0;z<CHUNK_SIZE;z++){
      const height = Math.floor(4 + 3*Math.sin((cx*CHUNK_SIZE + x)/6) + 2*Math.cos((cz*CHUNK_SIZE + z)/7));
      for(let y=0;y<CHUNK_SIZE;y++){
        const wy = y + 0; // local y (will shift by chunkY)
        if(y < height - 1) arr[x + z*CHUNK_SIZE + y*CHUNK_SIZE*CHUNK_SIZE] = 2; // dirt
        else if(y === height -1) arr[x + z*CHUNK_SIZE + y*CHUNK_SIZE*CHUNK_SIZE] = 1; // grass
        else arr[x + z*CHUNK_SIZE + y*CHUNK_SIZE*CHUNK_SIZE] = 0; // air
      }
    }
  }
  return arr;
}

// Instanced mesh pool per block type (cube geometry)
const cubeGeo = new THREE.BoxGeometry(1,1,1);
const instancedMeshes = new Map();
for(const b of BLOCK_TYPES){ if(b.id===0) continue; const mat = new THREE.MeshStandardMaterial({color:b.color}); const inst = new THREE.InstancedMesh(cubeGeo, mat, CHUNK_SIZE*CHUNK_SIZE*CHUNK_SIZE * WORLD_CHUNKS.x * WORLD_CHUNKS.z); inst.castShadow=true; inst.receiveShadow=true; inst.count = 0; scene.add(inst); instancedMeshes.set(b.id, inst); }

// Helper to get/set in chunk arr
function idx(x,y,z){return x + z*CHUNK_SIZE + y*CHUNK_SIZE*CHUNK_SIZE}
function getBlockAtWorld(wx,wy,wz){
  const cx = Math.floor(wx/CHUNK_SIZE), cz = Math.floor(wz/CHUNK_SIZE);
  const lx = ((wx%CHUNK_SIZE)+CHUNK_SIZE)%CHUNK_SIZE, lz = ((wz%CHUNK_SIZE)+CHUNK_SIZE)%CHUNK_SIZE, ly = wy;
  const key = chunkKey(cx,cz);
  const arr = chunks.get(key);
  if(!arr) return 0;
  if(ly<0 || ly>=CHUNK_SIZE) return 0;
  return arr[idx(lx,ly,lz)];
}
function setBlockAtWorld(wx,wy,wz, val){
  const cx = Math.floor(wx/CHUNK_SIZE), cz = Math.floor(wz/CHUNK_SIZE);
  const lx = ((wx%CHUNK_SIZE)+CHUNK_SIZE)%CHUNK_SIZE, lz = ((wz%CHUNK_SIZE)+CHUNK_SIZE)%CHUNK_SIZE, ly = wy;
  const key = chunkKey(cx,cz);
  const arr = chunks.get(key);
  if(!arr) return;
  if(ly<0 || ly>=CHUNK_SIZE) return;
  arr[idx(lx,ly,lz)] = val;
  markChunkDirty(key);
}

// Create world chunks
for(let cx=0; cx<WORLD_CHUNKS.x; cx++){
  for(let cz=0; cz<WORLD_CHUNKS.z; cz++){
    const key = chunkKey(cx,cz);
    chunks.set(key, makeChunk(cx,cz));
  }
}

// Dirty queue for re-baking
const dirty = new Set();
function markChunkDirty(key){ dirty.add(key); }

// Bake visible blocks into instanced meshes (simple greedy: add all non-air blocks)
function bakeAll(){
  // reset counts
  for(const inst of instancedMeshes.values()){ inst.count = 0; }
  const tmpMat = new THREE.Matrix4();
  const offsetY = 0;
  let counters = new Map();
  for(const [key, arr] of chunks.entries()){
    const [cx,cz] = key.split(',').map(Number);
    for(let x=0;x<CHUNK_SIZE;x++){
      for(let z=0;z<CHUNK_SIZE;z++){
        for(let y=0;y<CHUNK_SIZE;y++){
          const v = arr[idx(x,y,z)];
          if(v===0) continue;
          const worldX = x + cx*CHUNK_SIZE;
          const worldY = y + offsetY;
          const worldZ = z + cz*CHUNK_SIZE;
          const inst = instancedMeshes.get(v);
          if(!inst) continue;
          const count = counters.get(v) || 0;
          tmpMat.identity(); tmpMat.setPosition(worldX + 0.5, worldY + 0.5, worldZ + 0.5);
          inst.setMatrixAt(count, tmpMat);
          counters.set(v, count+1);
        }
      }
    }
  }
  // apply counts
  for(const [id, inst] of instancedMeshes.entries()){
    const c = counters.get(id) || 0; inst.count = c; inst.instanceMatrix.needsUpdate = true;
  }
}

bakeAll();

// Crosshair
const cross = document.createElement('div');
cross.style.position='absolute'; cross.style.left='50%'; cross.style.top='50%'; cross.style.width='6px'; cross.style.height='6px'; cross.style.margin='-3px 0 0 -3px'; cross.style.borderRadius='2px'; cross.style.background='rgba(255,255,255,0.9)'; cross.style.pointerEvents='none'; document.body.appendChild(cross);

// Player physics
const player = {velY:0, onGround:false};
const moveState = {forward:false,back:false,left:false,right:false};
let velocity = new THREE.Vector3();

// Input
window.addEventListener('keydown', (e)=>{
  if(e.code==='KeyW') moveState.forward=true;
  if(e.code==='KeyS') moveState.back=true;
  if(e.code==='KeyA') moveState.left=true;
  if(e.code==='KeyD') moveState.right=true;
  if(e.code==='Space'){ if(player.onGround){ player.velY = 8; player.onGround=false } }
  if(e.key>='1' && e.key<='6'){ selectedBlock = parseInt(e.key); updatePalette(); }
  if(e.key==='e' || e.key==='E'){ placeBlockAtCrosshair(); }
  if(e.key==='q' || e.key==='Q'){ removeBlockAtCrosshair(); }
  if(e.key==='s' || e.key==='S'){ saveWorld(); }
  if(e.key==='l' || e.key==='L'){ loadWorld(); }
});
window.addEventListener('keyup', (e)=>{ if(e.code==='KeyW') moveState.forward=false; if(e.code==='KeyS') moveState.back=false; if(e.code==='KeyA') moveState.left=false; if(e.code==='KeyD') moveState.right=false; });

// Raycast for crosshair interactions
const raycaster = new THREE.Raycaster();

function getCrosshairBlock(){
  raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
  const intersects = [];
  // we'll test by walking along ray and checking block occupancy
  const origin = raycaster.ray.origin.clone();
  const dir = raycaster.ray.direction.clone();
  for(let i=0;i<20;i++){
    const p = origin.clone().addScaledVector(dir, i*0.5);
    const bx = Math.floor(p.x), by = Math.floor(p.y), bz = Math.floor(p.z);
    const b = getBlockAtWorld(bx,by,bz);
    if(b!==0){ return {pos:[bx,by,bz], block:b}; }
  }
  return null;
}

function placeBlockAtCrosshair(){
  const hit = getCrosshairBlock();
  if(hit){
    // place adjacent in normal direction by using ray direction approximate
    const origin = raycaster.ray.origin.clone();
    const dir = raycaster.ray.direction.clone();
    // step from origin until just before block
    for(let i=0;i<20;i++){
      const p = origin.clone().addScaledVector(dir, i*0.5);
      const bx = Math.floor(p.x), by = Math.floor(p.y), bz = Math.floor(p.z);
      if(bx===hit.pos[0] && by===hit.pos[1] && bz===hit.pos[2]){
        // place at previous position
        const prev = origin.clone().addScaledVector(dir, Math.max(0,(i-1)*0.5));
        const px = Math.floor(prev.x), py = Math.floor(prev.y), pz = Math.floor(prev.z);
        setBlockAtWorld(px,py,pz, selectedBlock);
        markChunkDirty(chunkKey(Math.floor(px/CHUNK_SIZE), Math.floor(pz/CHUNK_SIZE)));
        bakeAll();
        return;
      }
    }
  } else {
    // place block at a short distance in front
    const p = raycaster.ray.origin.clone().addScaledVector(raycaster.ray.direction, 3);
    const px = Math.floor(p.x), py = Math.floor(p.y), pz = Math.floor(p.z);
    setBlockAtWorld(px,py,pz, selectedBlock);
    markChunkDirty(chunkKey(Math.floor(px/CHUNK_SIZE), Math.floor(pz/CHUNK_SIZE)));
    bakeAll();
  }
}
function removeBlockAtCrosshair(){
  const hit = getCrosshairBlock();
  if(hit){
    const [bx,by,bz] = hit.pos;
    setBlockAtWorld(bx,by,bz,0);
    markChunkDirty(chunkKey(Math.floor(bx/CHUNK_SIZE), Math.floor(bz/CHUNK_SIZE)));
    bakeAll();
  }
}

// UI palette
let selectedBlock = 1;
const paletteEl = document.getElementById('palette');
function updatePalette(){ paletteEl.innerHTML=''; for(let i=1;i<=6;i++){ const b=BLOCK_TYPES[i]; const btn=document.createElement('div'); btn.className='blockBtn'+(selectedBlock===i? ' sel':''); btn.title=`${i}: ${b.name}`; btn.style.background = '#' + b.color.toString(16).padStart(6,'0'); btn.innerText = b.name[0]; btn.onclick=()=>{selectedBlock=i; updatePalette();}; paletteEl.appendChild(btn);} }
updatePalette();

// Save/load
function saveWorld(){
  const data = {};
  for(const [k,arr] of chunks.entries()) data[k]=Array.from(arr);
  localStorage.setItem('mini-mc-3d-world', JSON.stringify(data));
  alert('World saved to localStorage.');
}
function loadWorld(){
  const v = localStorage.getItem('mini-mc-3d-world');
  if(!v){ alert('No save found.'); return }
  const obj = JSON.parse(v);
  for(const k of Object.keys(obj)){
    chunks.set(k, Uint8Array.from(obj[k]));
  }
  bakeAll();
  alert('World loaded.');
}

document.getElementById('saveBtn').onclick = saveWorld;
document.getElementById('loadBtn').onclick = loadWorld;
document.getElementById('exportBtn').onclick = ()=>{ const data = {}; for(const [k,arr] of chunks.entries()) data[k]=Array.from(arr); document.getElementById('importExport').value = JSON.stringify(data); };
document.getElementById('importBtn').onclick = ()=>{ try{ const v = document.getElementById('importExport').value; const obj = JSON.parse(v); for(const k of Object.keys(obj)) chunks.set(k, Uint8Array.from(obj[k])); bakeAll(); alert('Imported.'); }catch(e){ alert('Import failed: '+e.message); } };

document.getElementById('renderDist').addEventListener('change', (e)=>{ /* placeholder - we use small world for now */ });

// Resize
function onWindowResize(){ const w = window.innerWidth - 340; const h = window.innerHeight; renderer.setSize(Math.max(300,w), Math.max(240,h)); camera.aspect = (Math.max(300,w))/Math.max(240,h); camera.updateProjectionMatrix(); }
window.addEventListener('resize', onWindowResize); onWindowResize();

// Main loop
const clock = new THREE.Clock();
function animate(){
  const dt = Math.min(clock.getDelta(), 0.05);
  // movement
  const speed = 6;
  const dir = new THREE.Vector3();
  if(moveState.forward) dir.z -= 1;
  if(moveState.back) dir.z += 1;
  if(moveState.left) dir.x -= 1;
  if(moveState.right) dir.x += 1;
  dir.normalize();
  // convert to world space
  const matrix = new THREE.Matrix4(); matrix.extractRotation(camera.matrix);
  const move = new THREE.Vector3(dir.x,0,dir.z).applyMatrix4(matrix).multiplyScalar(speed*dt);
  camera.position.add(move);
  // gravity
  player.velY -= 9.8 * dt;
  camera.position.y += player.velY * dt;
  if(camera.position.y < 2){ camera.position.y = 2; player.velY = 0; player.onGround=true; }

  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);

// Initial camera position
camera.position.set(CHUNK_SIZE*WORLD_CHUNKS.x/2, 12, CHUNK_SIZE*WORLD_CHUNKS.z/2);

// Prevent context menu
canvas.addEventListener('contextmenu', e=>e.preventDefault());

// Simple instructions if pointer lock is unavailable
if(!('PointerLockControls' in window) && !controls){ console.log('PointerLock unavailable — fallback controls'); }

// Final: bake visuals now
bakeAll();

</script>
</body>
</html>
